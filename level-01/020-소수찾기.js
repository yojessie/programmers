// 2022-08-23

// 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
// 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다. (1은 소수가 아닙니다.)

// n은 2이상 1000000이하의 자연수입니다.

// 입출력 예 #1 : 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

function solution(n) {
  let answer = [];

  for (let i = 2; i <= n; i++) {
    answer.push(i);

    for (let j = 2; j < i; j++) {
      if (i % j == 0) {
        answer = answer.filter((item) => item !== i);
      }
    }
  }

  return answer.length;
}

// 쉽게 할수 있을 줄 알았다가 한참 걸린 문제
// 1부터 n까지의 수를 모두 배열로 만들어놓고, 소수가 아닌 수를 제거하는 방식으로 했다.
// 근데 이렇게하니까 런타임 에러 & 효율성 테스트에서 실패했다.
// 반복문을 돌리면, 최대 백만자리숫자를 모두 배열에 넣고 돌려야하니 그런가보다 ㅠㅠ

// 그래서 에라토스테네스의 체 방식을 이용하는게 좋다고 한다.
// n의 제곱근까지의 범위에서 소수가 되는 숫자의 배수가 되는 수를 모두 제외하면 소수만 남는다는 공식이다.
// n이 100이면, 100의 제곱근이 되는 10까지의 범위에서 소수가 되는 수의 배수들을 걸러낸다.
// 100까지 모두 확인하지않고, 10까지만 확인하면 되니까 효율성이 훨씬 올라가게 되는 건가보다.

// 그러니까 n까지의 전체 수를 적어놓고 2의 배수부터 싹 지운다.
// 3의 배수도 지우고, 4는 2의배수였으니까 건너뛰고, 5의 배수를 지우고... 이런식으로 진행하는건데
// 4는 2의배수이므로 체크하지 않아도되는 상황이 생기니까
// 배열에 숫자를 직접 넣어놓고 하는 것은 문제가 되므로
// 범위 내 숫자 수만큼 boolean을 넣어놓고 ture, flase로 체크하는 방식을 사용하는구나 했다.

function solution(n) {
  let answer = 0;

  let arr = Array(n + 1)
    .fill(true)
    .fill(false, 0, 2);
  // Array(n) n개만큼 배열 생성. 인덱스값 활용을 위해 0자리까지 만들어주려고 +1
  // 일단 모두 true로 채워놓고, 소수가 아닌것은 false로 변경 예정
  // 0과 1은 소수에서 제외하므로 미리 false 처리
  // (false를 0번째부터 2번째 '전'까지 채움)

  for (let i = 2; i * i <= n; i++) {
    // 최적화를 위해 제곱근이 되는 수 까지만 소수를 확인하면 된다는 점을 이용
    // 10 * 10 = 100 이므로 n이 100이라면 2 ~ 10까지만 확인하면 된다
    if (arr[i]) {
      // 만약 확인할 숫자가 true이면
      // 그 숫자가 어떤 수의 배수가 되는 수인지 확인하기 위해 한번더 loop
      for (let j = i * i; j <= n; j += i) {
        // 이부분 이해가 안됨 ㅠㅠ
        arr[j] = false;
      }
    }
  }

  for (let i = 2; i <= n; ++i) {
    // arr 아이템을 모두 체크해서 true의 갯수만큼 answer에 더해준다.
    if (arr[i] == true) {
      answer++;
    }
  }

  return answer;
}
